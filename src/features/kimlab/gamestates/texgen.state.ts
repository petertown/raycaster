import {
  GameState,
  RenderMode,
  StateAction,
  StateActionType,
} from 'src/abstract/game-state.abstract';
import { getIndicesForCoord } from 'src/functions/images.functions';
import { mod } from 'src/functions/math.functions';
import { ImageRequest } from 'src/models/image.model';
import { RendererCanvas } from 'src/renderers/canvas.renderer';

interface DistanceStored {
  distanceClosest: number; // closest point to the pixel
  distanceSecond: number; // second closest point
  closestPoint: number; // index of the point closest to the pixel
}

// A state to test out and experiment with generating textures
// Eventually I'll want a utility to do it, but for now try it out
// Should make a class that gets init with the details, and we can run "build" and it stores it for retrieval later
// For now, just get one type of texture (stone) working, then can make something similar for bricks
// Also need to config if it can wrap, individually on both sides, that way we can have textures that are horizontal or vertical or both
export class TexGenState extends GameState {
  genWidth = 64;
  genHeight = 64;
  generatedTex!: ImageData;

  // Textures are generated by using points to determine things like where stones are located
  pointMinDistance = 10; // If a point can't be any less than this, stop making points
  pointMaxCount = 32; // Stop making points if we've made more than this
  pointMaxDistance!: number;
  pointList!: { x: number; y: number }[];

  // Store the distance from the closest point
  distanceArray!: DistanceStored[][];

  // Params for editing the image
  noiseHeight = 5; // How much random noise to add
  edgeSize = 2; // Thickness of edges
  edgeSizeSquared!: number;
  stoneSmooth = 5; // Smoothness of stone
  stoneSmoothSquared!: number;

  getImageList(): ImageRequest[] {
    return [];
  }

  doInit() {
    this.edgeSizeSquared = this.edgeSize * this.edgeSize;

    this.createTexture();
  }

  createTexture() {
    this.buildTextureData();
    this.drawTextureImage();
  }

  buildTextureData() {
    // The texture image to draw to
    this.generatedTex = new ImageData(this.genWidth, this.genHeight);

    // Highest possible distance squared to start with
    this.pointMaxDistance = Math.sqrt(Math.pow(this.genWidth, 2) + Math.pow(this.genHeight, 2));

    // Build a list of distances from each point whise we'll update as we add points - so start with everything max distance
    this.distanceArray = [];
    for (let x = 0; x < this.genWidth; x++) {
      let distanceArrayColumn: DistanceStored[] = [];
      for (let y = 0; y < this.genHeight; y++) {
        distanceArrayColumn.push({
          distanceClosest: this.pointMaxDistance,
          distanceSecond: this.pointMaxDistance,
          closestPoint: -1,
        });
      }
      this.distanceArray.push(distanceArrayColumn);
    }

    // Pick a spot for the first one to go and to update for the next oneÆ’
    let largestDistancesList: { x: number; y: number }[];
    let nextX = Math.random() * this.genWidth;
    let nextY = Math.random() * this.genHeight;

    // Place the point from the last loop, smallestX/Y, and then recalculate the distance and find the furthest point (It'll be one of the corners first time)
    this.pointList = [];
    let point = 0;
    let canMakeMore = true;
    while (canMakeMore) {
      this.pointList.push({
        x: nextX,
        y: nextY,
      });
      let lastX = nextX;
      let lastY = nextY;

      // Find the largest possible distance for this pixel to place the next one
      largestDistancesList = []; // keep a list of the last largestDistancesAmount largest distances we've found

      // Update the distances based on how far it is from the new point, and find the smallest we have
      for (let x = 0; x < this.genWidth; x++) {
        for (let y = 0; y < this.genHeight; y++) {
          // Adjust the X and Y so that we wrap the texture, so we test against points on the other side too
          const adjustedDistanceX =
            mod(lastX - x + this.genWidth / 2.0, this.genWidth) - this.genWidth / 2.0;
          const adjustedDistanceY =
            mod(lastY - y + this.genHeight / 2.0, this.genHeight) - this.genHeight / 2.0;

          let distForPixel = Math.sqrt(
            Math.pow(adjustedDistanceX, 2) + Math.pow(adjustedDistanceY, 2),
          );

          // Compare that to what's already in the space
          const currentCalculation = this.distanceArray[x][y];
          if (distForPixel < currentCalculation.distanceClosest) {
            currentCalculation.closestPoint = point;
            currentCalculation.distanceSecond = currentCalculation.distanceClosest;
            currentCalculation.distanceClosest = distForPixel;
          } else {
            distForPixel = currentCalculation.distanceClosest;
          }

          // also check if it's eligible for a thing
          if (distForPixel > this.pointMinDistance) {
            largestDistancesList.push({ x: x, y: y });
          }
        }
      }

      // pick something random off the largestDistancesList
      if (largestDistancesList.length > 0) {
        let nextPosition =
          largestDistancesList[Math.floor(Math.random() * (largestDistancesList.length - 1))];
        nextX = nextPosition.x;
        nextY = nextPosition.y;
      } else {
        canMakeMore = false;
      }

      point++;
      if (point > this.pointMaxCount) {
        canMakeMore = false;
      }
    }
  }

  drawTextureImage() {
    // clear it to totally white first
    const data = this.generatedTex.data;
    for (let i = 0; i < data.length; i += 4) {
      data[i] = 255; // red
      data[i + 1] = 255; // green
      data[i + 2] = 255; // blue
      data[i + 3] = 255; // alpha
    }

    // Display what we got
    let texCoord: number;
    let texPercent: number;
    for (let x = 0; x < this.genWidth; x++) {
      for (let y = 0; y < this.genHeight; y++) {
        texCoord = getIndicesForCoord(x, y, this.genWidth, this.genHeight);
        let pixelCoord = this.distanceArray[x][y];

        // Just show a different shade for each point
        //texPercent = pixelCoord.closestPoint * (255 / (this.pointList.length - 1));
        //texPercent = (pixelCoord.distanceClosest / this.pointMinDistance) * 255;
        //this.generatedTex.data[texCoord] = texPercent;
        //this.generatedTex.data[texCoord + 1] = texPercent;
        //this.generatedTex.data[texCoord + 2] = texPercent;

        // we should move this into it's own array later, but for now TESTING
        // For that point, are we on an edge? We are on an edge if the pixels around it have different closest points
        let edge = false;
        for (let x2 = -this.edgeSize; x2 <= this.edgeSize; x2++) {
          for (let y2 = -this.edgeSize; y2 <= this.edgeSize; y2++) {
            if (!(x2 === 0 && y2 === 0)) {
              // check distance squared against the distance
              let distSquared = x2 * x2 + y2 * y2;

              if (
                distSquared <= this.edgeSizeSquared &&
                this.distanceArray[mod(x + x2, this.genWidth)][mod(y + y2, this.genHeight)]
                  .closestPoint !== pixelCoord.closestPoint
              ) {
                edge = true;
              }
            }
          }
        }

        if (edge) {
          let colour = edge ? 0 : 255;
          this.generatedTex.data[texCoord] = colour;
          this.generatedTex.data[texCoord + 1] = colour;
          this.generatedTex.data[texCoord + 2] = colour;
        } else {
          // If we aren't an edge, we will need to find out how many of the blocks in range are the same type
          // TODO: Actually let's make a new array which is the edges
          // And then another one which is the height of the stone at that point
          //    Each point has a height
          //    So if there's an edge, height 0, a stone, then height of that stone
          // And then we will blur the height of the stone on a smoothing step
          // Then we will add "grout" to the spaces that are greater than a certain level

          let colour = 128;
          this.generatedTex.data[texCoord] = colour;
          this.generatedTex.data[texCoord + 1] = colour;
          this.generatedTex.data[texCoord + 2] = colour;
        }
      }
    }
  }

  doLogic(deltaTime: number, keyboard: Map<string, boolean>): RenderMode {
    let updateTexture = false;

    if (keyboard.get('UP')) {
      this.pointMinDistance = Math.max(1, this.pointMinDistance - 1);
      updateTexture = true;
    } else if (keyboard.get('DOWN')) {
      this.pointMinDistance = Math.min(this.pointMaxDistance / 2, this.pointMinDistance + 1);
      updateTexture = true;
    } else if (keyboard.get('RIGHT')) {
      updateTexture = true;
    }

    if (updateTexture) {
      this.createTexture();
    }

    return RenderMode.None;
  }

  doCanvas(renderer: RendererCanvas): void {
    // blank the image
    renderer.clearImage();

    // Draw the image texture
    renderer.drawImageData(this.generatedTex);
  }

  updateState(): StateAction {
    return { action: StateActionType.None, newState: null };
  }
}
