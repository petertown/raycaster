import {
  GameState,
  RenderMode,
  StateAction,
  StateActionType,
} from 'src/abstract/game-state.abstract';
import { getIndicesForCoord } from 'src/functions/images.functions';
import { mod } from 'src/functions/math.functions';
import { ImageRequest } from 'src/models/image.model';
import { RendererCanvas } from 'src/renderers/canvas.renderer';

// A state to test out and experiment with generating textures
// Eventually I'll want a utility to do it, but for now try it out
export class TexGenState extends GameState {
  genWidth = 128;
  genHeight = 128;
  generatedTex!: ImageData;

  // Textures are generated by using points to determine things like where stones are located
  pointCount = 20; // probably a better name, since it wont just be stones
  pointList: { x: number; y: number; xd: number; yd: number }[] = [];

  getImageList(): ImageRequest[] {
    return [];
  }

  doInit() {
    // The texture image to draw to
    this.generatedTex = new ImageData(this.genWidth, this.genHeight);

    // Make a list of stones randomly all over the texture
    // Eventually want to make sure we dont put stones too close together but this is a pretest
    // Make the stones with random bigger than the scene, then mod then back so that it is a bit more evenly distributed
    for (let s = 0; s < this.pointCount; s++) {
      let sx = mod(Math.random() * this.genHeight * 100, this.genHeight);
      let sy = mod(Math.random() * this.genHeight * 100, this.genHeight);
      this.pointList.push({
        x: sx,
        y: sy,
        xd: (Math.random() - 0.5) / 100.0,
        yd: (Math.random() - 0.5) / 100.0,
      });
    }
  }

  updateTexture(deltaTime: number) {
    // adjust the stones movement
    for (let stone of this.pointList) {
      stone.x = mod(stone.x + stone.xd * deltaTime, this.genWidth);
      stone.y = mod(stone.y + stone.yd * deltaTime, this.genHeight);
    }
  }

  buildTexture() {
    // clear it to totally white first
    const data = this.generatedTex.data;
    for (let i = 0; i < data.length; i += 4) {
      data[i] = 255; // red
      data[i + 1] = 255; // green
      data[i + 2] = 255; // blue
      data[i + 3] = 255; // alpha
    }

    // make a 2D array for the entire thing for the distance from the closest brick
    let distanceArray: number[][] = [];
    const maxDistancePossible = Math.sqrt(Math.pow(this.genWidth, 2) + Math.pow(this.genHeight, 2)); // Highest possible distance squared to start with
    let maxDistanceFound = 0; // find the real max for normalising
    // Adjust the X and Y so that we wrap the texture, so we test against points on the other side
    let adjustedX: number;
    let adjustedY: number;

    for (let x = 0; x < this.genWidth; x++) {
      let distanceCol: number[] = [];
      for (let y = 0; y < this.genHeight; y++) {
        let distMin = maxDistancePossible;

        // For every single point, get the difference between the two closest points and save that
        for (let stone of this.pointList) {
          adjustedX = mod(stone.x - x + this.genWidth / 2.0, this.genWidth) - this.genWidth / 2.0;
          adjustedY =
            mod(stone.y - y + this.genHeight / 2.0, this.genHeight) - this.genHeight / 2.0;

          const distNew = Math.sqrt(Math.pow(adjustedX, 2) + Math.pow(adjustedY, 2));
          distMin = Math.min(distMin, distNew);
          maxDistanceFound = Math.max(distMin, maxDistanceFound);
        }

        distanceCol.push(distMin);
      }
      distanceArray.push(distanceCol);
    }

    // Display what we got
    let texCoord: number;
    let texPercent: number;
    let normalVal: number;
    for (let x = 0; x < this.genWidth; x++) {
      for (let y = 0; y < this.genHeight; y++) {
        texCoord = getIndicesForCoord(x, y, this.genWidth, this.genHeight);
        // make a percent for the distance at this point out of tempMax
        texPercent = distanceArray[x][y] / maxDistanceFound;
        normalVal = 255 * texPercent;
        this.generatedTex.data[texCoord] = normalVal;
        this.generatedTex.data[texCoord + 1] = normalVal;
        this.generatedTex.data[texCoord + 2] = normalVal;
      }
    }
  }

  doLogic(deltaTime: number, keyboard: Map<string, boolean>): RenderMode {
    this.updateTexture(deltaTime);

    this.buildTexture();

    return RenderMode.None;
    // Eventually, regenerate the texture every few seconds
    // Or better yet, slightly move the stone points and regenerate from that rather than all new
    // Move them based on the delta time, so give them a vector
  }

  doCanvas(renderer: RendererCanvas): void {
    // blank the image
    renderer.clearImage();

    // Draw the image texture
    renderer.drawImageData(this.generatedTex);
  }

  updateState(): StateAction {
    return { action: StateActionType.None, newState: null };
  }
}
