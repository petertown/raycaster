import { CoordinateXY } from '@models/coordinates.model';
import {
  GameState,
  RenderMode,
  StateAction,
  StateActionType,
} from 'src/abstract/game-state.abstract';
import { getIndicesForCoord } from 'src/functions/images.functions';
import { mod } from 'src/functions/math.functions';
import { ImageRequest } from 'src/models/image.model';
import { RendererCanvas } from 'src/renderers/canvas.renderer';
import { heightmapAdditionCombiner } from 'src/texturing/heightmap/combiner/heightmap-addition.combiner';
import { heightmapMultiplicationCombiner } from 'src/texturing/heightmap/combiner/heightmap-multiplication.combiner';
import { heightmapEdgeFilter } from 'src/texturing/heightmap/filters/heightmap-edge.filter';
import { heightmapNormaliseFilter } from 'src/texturing/heightmap/filters/heightmap-normalise.filter';
import { heightmapSmoothFilter } from 'src/texturing/heightmap/filters/heightmap-smoothing.filter';
import {
  DistanceCoord,
  generateHeightmapPointsAndDistances,
} from 'src/texturing/heightmap/generators/heightmap-points.generator';
import { generateSectionsHeightmap } from 'src/texturing/heightmap/generators/heightmap-sections.generator';
import { generateSurfaceSpotsHeightmap } from 'src/texturing/heightmap/generators/heightmap-spots.generator';

export interface TexturePoint {
  x: number;
  y: number;
  depth: number;
}

// A state to test out and experiment with generating textures
// Eventually I'll want a utility to do it, but for now try it out
// Should make a class that gets init with the details, and we can run "build" and it stores it for retrieval later
// For now, just get one type of texture (stone) working, then can make something similar for bricks
// Also need to config if it can wrap, individually on both sides, that way we can have textures that are horizontal or vertical or both
export class TexGenState extends GameState {
  genWidth = 128;
  genHeight = 128;
  textureImage!: ImageData;

  // Textures are generated by using points to determine things like where stones are located
  pointMaxCount!: number;
  pointMinDistance = Math.min(this.genWidth, this.genHeight) / 4; // If a point can't be any less than this, stop making points
  pointMaxDistance!: number;
  pointList!: CoordinateXY[];

  // Arrays to store everything about this texture surface
  distanceArray!: DistanceCoord[][];
  edgeArray!: boolean[][]; // is this an edge between the point areas
  depthArray!: number[][]; // Raw depth array

  // Params for editing the image
  noiseHeight = 5; // How much random noise to add
  edgeSize = 4; // Thickness of edges
  edgeSizeSquared!: number;
  stoneSmooth = 4; // Smooth edges of stone
  stoneDepthMin = 15;
  stoneDepthMax = 45;
  edgeDepth = 0;
  groutDepth = 5;

  getImageList(): ImageRequest[] {
    return [];
  }

  doInit() {
    this.edgeSizeSquared = this.edgeSize * this.edgeSize;
    this.pointMaxDistance = Math.sqrt(Math.pow(this.genWidth, 2) + Math.pow(this.genHeight, 2));

    this.createTexture();
  }

  createTexture() {
    this.pointMaxCount = Math.min(this.genWidth, this.genHeight) / this.pointMinDistance / 2; // Stop making points if we've made more than this

    // Create and clear the texture
    this.clearTextureData();
    this.drawTextureImage();
  }

  private clearTextureData() {
    this.textureImage = new ImageData(this.genWidth, this.genHeight);
    // clear it to totally white first
    for (let i = 0; i < this.textureImage.data.length; i += 4) {
      this.textureImage.data[i] = 255; // red
      this.textureImage.data[i + 1] = 255; // green
      this.textureImage.data[i + 2] = 255; // blue
      this.textureImage.data[i + 3] = 255;
    }
  }

  drawTextureImage() {
    // Build the texture fresh here by layering stuff, slowely get rid of everything in this component

    // Make the soft shapes
    let pointsAndDistances = generateHeightmapPointsAndDistances(
      this.genWidth,
      this.genHeight,
      2,
      Math.min(this.genWidth, this.genHeight) / 3.0,
    );
    let waves = generateSurfaceSpotsHeightmap(
      this.genWidth,
      this.genHeight,
      pointsAndDistances.points,
      48,
    );
    waves = heightmapSmoothFilter(waves, 24);
    waves = heightmapNormaliseFilter(waves, 64, 0);

    // Make the bricks
    pointsAndDistances = generateHeightmapPointsAndDistances(
      this.genWidth,
      this.genHeight,
      this.pointMaxCount,
      this.pointMinDistance,
    );
    let bricks = generateSectionsHeightmap(
      pointsAndDistances.distances,
      this.stoneDepthMin,
      this.stoneDepthMax,
    );
    let brickEdges = heightmapEdgeFilter(pointsAndDistances.distances, this.edgeSize);
    brickEdges = heightmapSmoothFilter(brickEdges, this.stoneSmooth);

    // add the two together
    let combined = heightmapAdditionCombiner(waves, bricks);
    combined = heightmapMultiplicationCombiner(combined, brickEdges);

    // Display what we got
    let texCoord: number;
    for (let x = 0; x < this.genWidth; x++) {
      for (let y = 0; y < this.genHeight; y++) {
        texCoord = getIndicesForCoord(x, y, this.genWidth, this.genHeight);
        //let colour = this.depthArray[x][y] * 5;
        let colour = combined[x][y];
        this.textureImage.data[texCoord] = colour;
        this.textureImage.data[texCoord + 1] = colour;
        this.textureImage.data[texCoord + 2] = colour;
      }
    }
  }

  doLogic(deltaTime: number, keyboard: Map<string, boolean>): RenderMode {
    let updateTexture = false;

    if (keyboard.get('UP')) {
      this.pointMinDistance = Math.max(1, this.pointMinDistance - 1);
      updateTexture = true;
    } else if (keyboard.get('DOWN')) {
      this.pointMinDistance = Math.min(this.pointMaxDistance / 2, this.pointMinDistance + 1);
      updateTexture = true;
    } else if (keyboard.get('RIGHT')) {
      updateTexture = true;
    }

    if (updateTexture) {
      this.createTexture();
    }

    return RenderMode.None;
  }

  doCanvas(renderer: RendererCanvas): void {
    // blank the image
    renderer.clearImage();

    // Draw the image texture
    renderer.drawImageData(this.textureImage);
  }

  updateState(): StateAction {
    return { action: StateActionType.None, newState: null };
  }
}
